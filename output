= Parsing ======================================================================
Preprocessing
  Destination: /var/folders/z_/mk3xy1tx2cz44rhrx5xfsj4m0000gn/T/Cairo_true-termination2838a5.i
= Pointer analysis =============================================================
= Forward invariant generation =================================================
In: (TransitionSystem.Make.PAxBox.State (, ))
Transition: {x := havoc:0
             when 0 <= havoc:0}
Out: (TransitionSystem.Make.PAxBox.State (0 <= x:1, x -> [0, +oo]))
In: (TransitionSystem.Make.PAxBox.State (0 <= x:1, x -> [0, +oo]))
Transition: {when 0 < x:1}
Out: (TransitionSystem.Make.PAxBox.State (
        0 <= x:1, 0 < x:1, (x:1 < 0 \/ 0 < x:1), x -> [1, +oo]))
In: (TransitionSystem.Make.PAxBox.State (
       0 <= x:1, 0 < x:1, (x:1 < 0 \/ 0 < x:1), x -> [1, +oo]))
Transition: {}
Out: (TransitionSystem.Make.PAxBox.State (
        0 <= x:1, 0 < x:1, (x:1 < 0 \/ 0 < x:1), x -> [1, +oo]))
In: (TransitionSystem.Make.PAxBox.State (
       0 <= x:1, 0 < x:1, (x:1 < 0 \/ 0 < x:1), x -> [1, +oo]))
Transition: {x := (x:1 + -2)
             when (x:1 < 0 \/ 0 < x:1)}
Out: (TransitionSystem.Make.PAxBox.State (, x -> [-1, +oo]))
In: (TransitionSystem.Make.PAxBox.State (0 <= x:1, x -> [0, +oo]))
Transition: {when 0 < x:1}
Out: (TransitionSystem.Make.PAxBox.State (
        0 <= x:1, 0 < x:1, (x:1 < 0 \/ 0 < x:1), x -> [1, +oo]))
In: (TransitionSystem.Make.PAxBox.State (, x -> [-1, +oo]))
Transition: {}
Out: (TransitionSystem.Make.PAxBox.State (, x -> [-1, +oo]))
In: (TransitionSystem.Make.PAxBox.State (, x -> [-1, +oo]))
Transition: {x := (x:1 + -2)
             when (x:1 < 0 \/ 0 < x:1)}
Out: (TransitionSystem.Make.PAxBox.State (, x -> [-3, +oo]))
In: (TransitionSystem.Make.PAxBox.State (0 <= x:1, x -> [0, +oo]))
Transition: {when 0 < x:1}
Out: (TransitionSystem.Make.PAxBox.State (
        0 <= x:1, 0 < x:1, (x:1 < 0 \/ 0 < x:1), x -> [1, +oo]))
In: (TransitionSystem.Make.PAxBox.State (, x -> [-3, +oo]))
Transition: {}
Out: (TransitionSystem.Make.PAxBox.State (, x -> [-3, +oo]))
In: (TransitionSystem.Make.PAxBox.State (, x -> [-3, +oo]))
Transition: {x := (x:1 + -2)
             when (x:1 < 0 \/ 0 < x:1)}
Out: (TransitionSystem.Make.PAxBox.State (, x -> [-5, +oo]))
In: (TransitionSystem.Make.PAxBox.State (0 <= x:1, x -> [0, +oo]))
Transition: {when 0 < x:1}
Out: (TransitionSystem.Make.PAxBox.State (
        0 <= x:1, 0 < x:1, (x:1 < 0 \/ 0 < x:1), x -> [1, +oo]))
In: (TransitionSystem.Make.PAxBox.State (, ))
Transition: {}
Out: (TransitionSystem.Make.PAxBox.State (, ))
In: (TransitionSystem.Make.PAxBox.State (, ))
Transition: {x := (x:1 + -2)
             when (x:1 < 0 \/ 0 < x:1)}
Out: (TransitionSystem.Make.PAxBox.State (, ))
In: (TransitionSystem.Make.PAxBox.State (0 <= x:1, x -> [0, +oo]))
Transition: {when 0 < x:1}
Out: (TransitionSystem.Make.PAxBox.State (
        0 <= x:1, 0 < x:1, (x:1 < 0 \/ 0 < x:1), x -> [1, +oo]))
In: (TransitionSystem.Make.PAxBox.State (, ))
Transition: {when (0 <= x:1 /\ x:1 <= 0)}
Out: (TransitionSystem.Make.PAxBox.State (
        0 <= x:1, x:1 <= 0, (0 <= x:1 /\ x:1 <= 0), x -> [0, 0]))
In: (TransitionSystem.Make.PAxBox.State (0 <= x:1, x -> [0, +oo]))
Transition: {when x:1 <= 0}
Out: (TransitionSystem.Make.PAxBox.State (
        0 <= x:1, x:1 <= 0, (0 <= x:1 /\ x:1 <= 0), x -> [0, 0]))
In: (TransitionSystem.Make.PAxBox.State (
       0 <= x:1, x:1 <= 0, (0 <= x:1 /\ x:1 <= 0), x -> [0, 0]))
Transition: {return := 0
             return@pos := type_err:7
             return@width := type_err:8}
Out: (TransitionSystem.Make.PAxBox.State (
        0 <= x:1, x:1 <= 0, (0 <= x:1 /\ x:1 <= 0),
        x -> [0, 0], return -> [0, 0]))
Found invariant at 5: true
Testing Quick Look preview with files:
	/var/folders/z_/mk3xy1tx2cz44rhrx5xfsj4m0000gn/T/graphbc39f9.png


Computing loop nesting relations at level 0
number of non-trivial SCCs: 1
SCCs:
0: 24 
1: 18 
2: 25 9 5 
3: 17 
4: 23 
... finding a header and a backedge ... 

======== Loop ======== 
header: 5
splitted_hd: 5
depth: 0
back edge: 9 5
loop body:
25 9 5 
Children's headers:
====== end loop ======


Computing loop nesting relations at level 1
Cannot find non-trivial SCC at level 1
... trying to assign child loops to parent loops
parent list:
0:{}
1:{}
2:
======== Loop ======== 
header: 5
splitted_hd: 5
depth: 0
back edge: 9 5
loop body:
25 9 5 
Children's headers:
====== end loop ======
3:{}
4:{}
children list:
... computing body weight of the following loop:

======== Loop ======== 
header: 5
splitted_hd: 5
depth: 0
back edge: 9 5
loop body:
25 9 5 
Children's headers:
====== end loop ======
this loop is a terminal loop... now trying to split header of the following loop:

======== Loop ======== 
header: 5
splitted_hd: 5
depth: 0
back edge: 9 5
loop body:
25 9 5 
Children's headers:
====== end loop ======
new vertex has number: 26
Abstracting formula
((x:1 < 0 \/ -x:1 < 0) /\ (2 + -x:1 + x':93) = 0)
Blocking clause true
Admitted int: 0 -> x:1
Admitted int: 1 -> x':93
Admitted int: 0 -> x:1
Admitted int: 1 -> x':93
Projection input: [|-x:1+x':93+2=0; x:1-1>=0|]
Compute a Grobner basis for:
b --> (a) + -2*(1)
After reduction:
b --> (a) + -2*(1)
Grobner basis:
b --> (a) + -2*(1)
Admitted int: 0 -> x:1
Admitted int: 1 -> x':93
Env (2): [0 -> x:1 (int)
          1 -> x':93 (int)
          ]
Replace x:1 => x:1
Replace x':93 => x':93
Projection result: [|-x:1+x':93+2=0; x:1-1>=0|]
Before strengthen: [|-x:1+x':93+2=0; x:1-1>=0|]
Compute a Grobner basis for:
b --> (a) + -2*(1)
After reduction:
b --> (a) + -2*(1)
Grobner basis:
b --> (a) + -2*(1)
Rewrite: x':93 --> (x:1) + -2*(1)
Integrity: (x':93 + -x:1 + 2) = 0 => x':93 = (-2 + x:1)
Compute a Grobner basis for:
b --> (a) + -2*(1)
After reduction:
b --> (a) + -2*(1)
Grobner basis:
b --> (a) + -2*(1)
Rewrite: x':93 --> (x:1) + -2*(1)
Integrity: (x':93 + -x:1 + 2) = 0 => x':93 = (-2 + x:1)
After strengthen: [|-x:1+x':93+2=0; x:1-1>=0|]
Blocking clause !(((2 + -x:1 + x':93) = 0 /\ 0 <= (-1 + x:1)))
Admitted int: 0 -> x:1
Admitted int: 1 -> x':93
Admitted int: 0 -> x:1
Admitted int: 1 -> x':93
Projection input: [|-x:1+x':93+2=0; -x:1-1>=0|]
Compute a Grobner basis for:
b --> (a) + -2*(1)
After reduction:
b --> (a) + -2*(1)
Grobner basis:
b --> (a) + -2*(1)
Admitted int: 0 -> x:1
Admitted int: 1 -> x':93
Env (2): [0 -> x:1 (int)
          1 -> x':93 (int)
          ]
Replace x:1 => x:1
Replace x':93 => x':93
Projection result: [|-x:1+x':93+2=0; -x:1-1>=0|]
Admitted int: 0 -> x:1
Admitted int: 1 -> x':93
Before strengthen: [|-x:1+x':93+2=0; x:1-1>=0|]
Compute a Grobner basis for:
b --> (a) + -2*(1)
After reduction:
b --> (a) + -2*(1)
Grobner basis:
b --> (a) + -2*(1)
Rewrite: x':93 --> (x:1) + -2*(1)
Integrity: (x':93 + -x:1 + 2) = 0 => x':93 = (-2 + x:1)
Compute a Grobner basis for:
b --> (a) + -2*(1)
After reduction:
b --> (a) + -2*(1)
Grobner basis:
b --> (a) + -2*(1)
Rewrite: x':93 --> (x:1) + -2*(1)
Integrity: (x':93 + -x:1 + 2) = 0 => x':93 = (-2 + x:1)
After strengthen: [|-x:1+x':93+2=0; x:1-1>=0|]
Before strengthen: [|-x:1+x':93+2=0; -x:1-1>=0|]
Compute a Grobner basis for:
b --> (a) + -2*(1)
After reduction:
b --> (a) + -2*(1)
Grobner basis:
b --> (a) + -2*(1)
Rewrite: x':93 --> (x:1) + -2*(1)
Integrity: (x':93 + -x:1 + 2) = 0 => x':93 = (-2 + x:1)
Compute a Grobner basis for:
b --> (a) + -2*(1)
After reduction:
b --> (a) + -2*(1)
Grobner basis:
b --> (a) + -2*(1)
Rewrite: x':93 --> (x:1) + -2*(1)
Integrity: (x':93 + -x:1 + 2) = 0 => x':93 = (-2 + x:1)
After strengthen: [|-x:1+x':93+2=0; -x:1-1>=0|]
Blocking clause !((2 + -x:1 + x':93) = 0)
Abstraction result:
[|-x:1+x':93+2=0|]
Projection input: [|-x:1+x':93+2=0|]
Compute a Grobner basis for:
b --> (a) + -2*(1)
After reduction:
b --> (a) + -2*(1)
Grobner basis:
b --> (a) + -2*(1)
Admitted int: 0 -> x:1
Env (1): [0 -> x:1 (int)
          ]
Replace x:1 => x:1
Remove 1 int, 0 real: 1
Projection result: top
Projection input: [|-x:1+x':93+2=0|]
Compute a Grobner basis for:
a --> (b) + 2*(1)
After reduction:
a --> (b) + 2*(1)
Grobner basis:
a --> (b) + 2*(1)
Admitted int: 0 -> x':93
Env (1): [0 -> x':93 (int)
          ]
Replace x':93 => x':93
Remove 1 int, 0 real: 1
Projection result: top
New stratum (0 terms)
Compute a Grobner basis for:

After reduction:

Grobner basis:

Compute a Grobner basis for:
b --> (a) + -2*(1)
After reduction:
b --> (a) + -2*(1)
Grobner basis:
b --> (a) + -2*(1)
Vanishing ideal:
  (-2)*1 + w[x:1] + (-1)*w[x':93]
Solving system:
M:  0
b:  [0:1]
Solving system:
M:  {0, 1} x {0, 1}
    [1, -1]
    [0, 1]
b:  [1:1]
Solution: [0:1, 1:1]
Solving system:
M:  {0} x {0}
    [1]
b:  [0:1]
Solution: [0:1]
Affine transformation:
 A: {0} x {0}
    [1]
 B: {0} x {0}
    [1]
New stratum (1 terms)
Compute a Grobner basis for:
a --> (c)
b --> (a) + -2*(1)
After reduction:
a --> (c)
b --> (c) + -2*(1)
Grobner basis:
a --> (c)
b --> (c) + -2*(1)
Compute a Grobner basis for:

After reduction:

Grobner basis:

Vanishing ideal:
Affine transformation:
 A: 0
 B: 0
Admitted int: 0 -> delta_x:94
Admitted int: 1 -> x':93
Admitted int: 2 -> x:1
Admitted int: 3 -> a[x:1]:95
Projection input: [|-x':93+a[x:1]:95-2=0; -x':93+x:1-2=0; delta_x:94+2=0|]
Compute a Grobner basis for:
c --> (b) + 2*(1)
a --> -2*(1)
b --> (d) + -2*(1)
After reduction:
c --> (d)
a --> -2*(1)
b --> (d) + -2*(1)
Grobner basis:
c --> (d)
a --> -2*(1)
b --> (d) + -2*(1)
Admitted int: 0 -> delta_x:94
Admitted int: 1 -> a[x:1]:95
Env (2): [0 -> delta_x:94 (int)
          1 -> a[x:1]:95 (int)
          ]
Replace delta_x:94 => delta_x:94
Replace a[x:1]:95 => a[x:1]:95
Remove 2 int, 0 real: 2, 3
Projection result: [|delta_x:94+2=0|]
Block:
| 0_{k + 1} | == | 1 | * | 0_k | + | ((-2)) |
Abstracting formula
((x:1 < 0 \/ -x:1 < 0) /\ (2 + -x:1 + x':93) = 0)
Blocking clause true
Admitted int: 0 -> x:1
Admitted int: 1 -> x':93
Admitted int: 0 -> x:1
Admitted int: 1 -> x':93
Projection input: [|-x:1+x':93+2=0; x:1-1>=0|]
Compute a Grobner basis for:
b --> (a) + -2*(1)
After reduction:
b --> (a) + -2*(1)
Grobner basis:
b --> (a) + -2*(1)
Admitted int: 0 -> x:1
Admitted int: 1 -> x':93
Env (2): [0 -> x:1 (int)
          1 -> x':93 (int)
          ]
Replace x:1 => x:1
Replace x':93 => x':93
Projection result: [|-x:1+x':93+2=0; x:1-1>=0|]
Before strengthen: [|-x:1+x':93+2=0; x:1-1>=0|]
Compute a Grobner basis for:
b --> (a) + -2*(1)
After reduction:
b --> (a) + -2*(1)
Grobner basis:
b --> (a) + -2*(1)
Rewrite: x':93 --> (x:1) + -2*(1)
Integrity: (x':93 + -x:1 + 2) = 0 => x':93 = (-2 + x:1)
Compute a Grobner basis for:
b --> (a) + -2*(1)
After reduction:
b --> (a) + -2*(1)
Grobner basis:
b --> (a) + -2*(1)
Rewrite: x':93 --> (x:1) + -2*(1)
Integrity: (x':93 + -x:1 + 2) = 0 => x':93 = (-2 + x:1)
After strengthen: [|-x:1+x':93+2=0; x:1-1>=0|]
Blocking clause !(((2 + -x:1 + x':93) = 0 /\ 0 <= (-1 + x:1)))
Admitted int: 0 -> x:1
Admitted int: 1 -> x':93
Admitted int: 0 -> x:1
Admitted int: 1 -> x':93
Projection input: [|-x:1+x':93+2=0; -x:1-1>=0|]
Compute a Grobner basis for:
b --> (a) + -2*(1)
After reduction:
b --> (a) + -2*(1)
Grobner basis:
b --> (a) + -2*(1)
Admitted int: 0 -> x:1
Admitted int: 1 -> x':93
Env (2): [0 -> x:1 (int)
          1 -> x':93 (int)
          ]
Replace x:1 => x:1
Replace x':93 => x':93
Projection result: [|-x:1+x':93+2=0; -x:1-1>=0|]
Admitted int: 0 -> x:1
Admitted int: 1 -> x':93
Before strengthen: [|-x:1+x':93+2=0; x:1-1>=0|]
Compute a Grobner basis for:
b --> (a) + -2*(1)
After reduction:
b --> (a) + -2*(1)
Grobner basis:
b --> (a) + -2*(1)
Rewrite: x':93 --> (x:1) + -2*(1)
Integrity: (x':93 + -x:1 + 2) = 0 => x':93 = (-2 + x:1)
Compute a Grobner basis for:
b --> (a) + -2*(1)
After reduction:
b --> (a) + -2*(1)
Grobner basis:
b --> (a) + -2*(1)
Rewrite: x':93 --> (x:1) + -2*(1)
Integrity: (x':93 + -x:1 + 2) = 0 => x':93 = (-2 + x:1)
After strengthen: [|-x:1+x':93+2=0; x:1-1>=0|]
Before strengthen: [|-x:1+x':93+2=0; -x:1-1>=0|]
Compute a Grobner basis for:
b --> (a) + -2*(1)
After reduction:
b --> (a) + -2*(1)
Grobner basis:
b --> (a) + -2*(1)
Rewrite: x':93 --> (x:1) + -2*(1)
Integrity: (x':93 + -x:1 + 2) = 0 => x':93 = (-2 + x:1)
Compute a Grobner basis for:
b --> (a) + -2*(1)
After reduction:
b --> (a) + -2*(1)
Grobner basis:
b --> (a) + -2*(1)
Rewrite: x':93 --> (x:1) + -2*(1)
Integrity: (x':93 + -x:1 + 2) = 0 => x':93 = (-2 + x:1)
After strengthen: [|-x:1+x':93+2=0; -x:1-1>=0|]
Blocking clause !((2 + -x:1 + x':93) = 0)
Abstraction result:
[|-x:1+x':93+2=0|]
Projection input: [|-x:1+x':93+2=0|]
Compute a Grobner basis for:
b --> (a) + -2*(1)
After reduction:
b --> (a) + -2*(1)
Grobner basis:
b --> (a) + -2*(1)
Admitted int: 0 -> x:1
Env (1): [0 -> x:1 (int)
          ]
Replace x:1 => x:1
Remove 1 int, 0 real: 1
Projection result: top
Projection input: [|-x:1+x':93+2=0|]
Compute a Grobner basis for:
a --> (b) + 2*(1)
After reduction:
a --> (b) + 2*(1)
Grobner basis:
a --> (b) + 2*(1)
Admitted int: 0 -> x':93
Env (1): [0 -> x':93 (int)
          ]
Replace x':93 => x':93
Remove 1 int, 0 real: 1
Projection result: top
New stratum (0 terms)
Compute a Grobner basis for:

After reduction:

Grobner basis:

Compute a Grobner basis for:
b --> (a) + -2*(1)
After reduction:
b --> (a) + -2*(1)
Grobner basis:
b --> (a) + -2*(1)
Vanishing ideal:
  (-2)*1 + w[x:1] + (-1)*w[x':93]
Solving system:
M:  0
b:  [0:1]
Solving system:
M:  {0, 1} x {0, 1}
    [1, -1]
    [0, 1]
b:  [1:1]
Solution: [0:1, 1:1]
Solving system:
M:  {0} x {0}
    [1]
b:  [0:1]
Solution: [0:1]
Affine transformation:
 A: {0} x {0}
    [1]
 B: {0} x {0}
    [1]
New stratum (1 terms)
Compute a Grobner basis for:
a --> (c)
b --> (a) + -2*(1)
After reduction:
a --> (c)
b --> (c) + -2*(1)
Grobner basis:
a --> (c)
b --> (c) + -2*(1)
Compute a Grobner basis for:

After reduction:

Grobner basis:

Vanishing ideal:
Affine transformation:
 A: 0
 B: 0
Admitted int: 0 -> delta_x:102
Admitted int: 1 -> x':93
Admitted int: 2 -> x:1
Admitted int: 3 -> a[x:1]:103
Projection input: [|-x':93+a[x:1]:103-2=0; -x':93+x:1-2=0; delta_x:102+2=0|]
Compute a Grobner basis for:
c --> (b) + 2*(1)
a --> -2*(1)
b --> (d) + -2*(1)
After reduction:
c --> (d)
a --> -2*(1)
b --> (d) + -2*(1)
Grobner basis:
c --> (d)
a --> -2*(1)
b --> (d) + -2*(1)
Admitted int: 0 -> delta_x:102
Admitted int: 1 -> a[x:1]:103
Env (2): [0 -> delta_x:102 (int)
          1 -> a[x:1]:103 (int)
          ]
Replace delta_x:102 => delta_x:102
Replace a[x:1]:103 => a[x:1]:103
Remove 2 int, 0 real: 2, 3
Projection result: [|delta_x:102+2=0|]
Block:
| 0_{k + 1} | == | 1 | * | 0_k | + | ((-2)) |



********* Printing flattened loops **********


0-th loop:
path to header: (WeightedGraph.Weight
   {x := x':106
    when (0 <= havoc:0 /\ 0 < havoc:0
            /\ (!(0 <= K:97) \/ x':98 = (havoc:0 + (-2 * K:97)))
            /\ ((K:97 = 0 /\ havoc:0 = x':98) \/ 1 <= K:97) /\ 0 <= K:97
            /\ (!(0 <= K:105) \/ x':106 = (x':98 + (-2 * K:105)))
            /\ ((K:105 = 0 /\ x':98 = x':106) \/ 1 <= K:105) /\ 0 <= K:105)})
loop body: (WeightedGraph.Weight {x := (x:1 + -2)
                       when (x:1 < 0 \/ 0 < x:1)})
======= printing poly loop body


[1] abstract lazy_dnf
Admitted int: 0 -> havoc:0
Admitted int: 1 -> K:97
Admitted int: 2 -> x':98
Admitted int: 3 -> K:105
Admitted int: 4 -> x':106
Admitted int: 5 -> x':93
[2] abstract lazy_dnf
[3] abstract lazy_dnf

Invariant formula:
true


[1] abstract lazy_dnf
Admitted int: 0 -> x:1
Admitted int: 1 -> x':93
[2] abstract lazy_dnf
Loop body formula:
((2 + -x:1) + x':93) = 0


Admitted int: 0 -> x:1
Admitted int: 1 -> x':93
-2 + x:1 + -1 * (x':93) = 0

Constraints lambda_1 >= 0:


(0 <= l:107 /\ 0 <= l:108)


Constraints lambda_2 >= 0:


(0 <= r:109 /\ 0 <= r:110)


Constraints eq1:


(l:108 + -l:107) = 0


Constraints eq2:


(-((l:108 + -r:110)) + (l:107 + -r:109)) = 0


Constraints eq3:


true


Constraints eq4:


((-2 * r:110) + (2 * r:109)) < 0

linear ranking function does not exist
